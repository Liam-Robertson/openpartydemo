com.openparty.app
├── core
├── di
│   └── BudgetModule.kt
├── feature_budget
│   ├── data
│   │   ├── datasource
│   │   │   └── BudgetDataSource.kt
│   │   └── repository
│   │       └── BudgetRepositoryImpl.kt
│   ├── domain
│   │   ├── model
│   │   │   ├── BudgetItem.kt
│   │   │   └── BudgetResponse.kt
│   │   ├── repository
│   │   │   └── BudgetRepository.kt
│   │   └── usecase
│   │       └── GetBudgetDataUseCase.kt
│   └── presentation
│       ├── components
│       │   ├── BudgetPieChart.kt
│       │   └── Legend.kt
│       ├── BudgetContent.kt
│       ├── BudgetScreen.kt
│       └── BudgetViewModel.kt
│── navigation
│   ├── AppNavHost.kt
│   ├── BottomNavBar.kt
│   └── Screen.kt
│── ui.theme
│   ├── Color.kt
│   ├── Theme.kt
│   └── Type.kt
├── MainActivity.kt
└── MyApplication.kt

---------------------------------

Budget Screen:
- The aim of the budget screen is to represent the amount of spending in each area of government in pie chart form
- It gets information about government spending from a database, calculates the percentage spending in each area, then displays that information to the user in a pie chart
- The budget screen has three parts:
    - A title saying "Budget"
    - A pie chart. This has a legend showing what each section corresponds to
    - A footer:
        - The footer is used for navigation
        - It is made up of three sections - a budget section, a newsfeed section and a proposals section
        - Each section is represented by an icon
        - When the user clicks on a section, it navigates to that page
        - When the app is first opens, it defaults navigation to the budget section
        - When the budget screen is open, the budget section is highlighted. When the minutes screen is open, the minutes section is highlighted

When the user enters the budget screen this happens:
- The data about the financial report is fetched
    - The data about the financial report will be stored in a separate file
    - Right now this is just a version 1 of an app, so the data will be hardcoded
    - The data will be hardcoded for each section
    - The data will be in this format:
{
  "areas_of_spending": [
    {
      "type_of_spending": "Education Services",
      "cost": "£220.806 million",
      "summary": "This category encompasses all spending related to educational services provided by the council, including staffing costs for teachers and support staff, educational materials, school maintenance, and administrative support.",
      "subtypes_level_1": [
        {
          "type_of_spending": "Schools and Education Support",
          "cost": "£220.806 million",
          "summary": "This subtype includes costs for teaching staff salaries, educational materials, school facility maintenance, special education needs, and administrative support services.",
          "subtypes_level_2": [
            {
              "type_of_spending": "Early Learning and Childcare",
              "cost": "£17.850 million",
              "summary": "Provision of early childhood education and childcare services for children under the age of five."
            },
.....

    - i.e. the data will be in json format with the area of spending, the cost the summary and then the same again for all the subtypes of spending
    - When the user enters the screen, the data will be fetched from the json file which is com.openparty.app.notes.descriptionsV1.financeDataV1.json
    - This data will then be used to populate the pie chart
    - The pie chart will initially just be populated using the highest level of data i.e. type of spending, not type of spending level 1 or level 2
    - There will be a legend at the bottom of the screen which shows each area of spending, it's cost and it's colour on the pie chart
    - If the user clicks on a section in the legend, the app shows a new pie chart which gives a more detailed breakdown of that type of spending
    - For example, the initial pie chart might show up with Education Services, Social Care Services, Housing services
    - Each of these would be represented in the pie chart as a different colour, and each would take up a piece of the pie chart proportional to the level of spending on them
        - e.g. if Education was 37% of spending it would take up 37% of the pie chart
    - At the bottom of the screen is a legend showing Education Services, Social Care Services, Housing services - along with the colour and cost associated with each
    - If the user then clicked on Social Care Services in the legend, a new pie chart would appear which has all the subtypes of Social Care Services spending
        - i.e."Adult and Elderly Services (IJB)", "Children's Services (Non-IJB)"
    - The new pie chart would have each sub type of spending
    - The new legend would have the sub type of spending, the colour on the pie chart, the cost
    - If the user clicks on a subtype of spending in the legend, then a new pie chart would appear for sub type level 2
    - The new pie chart and legend would have the type of spending, cost and colour for spending sub type 2 in the json file

Navigation:
- The navigation needs to be able to handle navigating between the budget section, newsfeed section and proposals section
- This app is going to get a lot more complex so the navigation functionality needs to be able to handle that
- The navigation should probably have it's own feature

---------------------------------

// File: feature-budget/src/main/java/com/openparty/feature_budget/data/datasource/BudgetDataSource.kt
package com.openparty.app.feature_budget.data.datasource

import android.content.Context
import com.openparty.app.feature_budget.domain.model.BudgetItem
import com.openparty.app.feature_budget.domain.model.BudgetResponse
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.json.Json

class BudgetDataSource @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val jsonFormat = Json { ignoreUnknownKeys = true }

    suspend fun fetchBudgetData(): List<BudgetItem> {
        val jsonString = withContext(Dispatchers.IO) {
            context.assets.open("financeDataV1.json").bufferedReader().use { it.readText() }
        }
        val response = jsonFormat.decodeFromString<BudgetResponse>(jsonString)
        return response.areasOfSpending
    }
}
// File: feature-budget/src/main/java/com/openparty/feature_budget/data/repository/BudgetRepositoryImpl.kt
package com.openparty.app.feature_budget.data.repository

import com.openparty.app.feature_budget.data.datasource.BudgetDataSource
import com.openparty.app.feature_budget.domain.model.BudgetItem
import com.openparty.app.feature_budget.domain.repository.BudgetRepository
import javax.inject.Inject

class BudgetRepositoryImpl @Inject constructor(
    private val dataSource: BudgetDataSource
) : BudgetRepository {
    override suspend fun getBudgetData(): List<BudgetItem> {
        return dataSource.fetchBudgetData()
    }
}
// File: feature-budget/src/main/java/com/openparty/feature_budget/di/BudgetModule.kt
package com.openparty.app.feature_budget.di

import com.openparty.app.feature_budget.data.datasource.BudgetDataSource
import com.openparty.app.feature_budget.data.repository.BudgetRepositoryImpl
import com.openparty.app.feature_budget.domain.repository.BudgetRepository
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object BudgetModule {

    @Provides
    @Singleton
    fun provideBudgetRepository(
        dataSource: BudgetDataSource
    ): BudgetRepository = BudgetRepositoryImpl(dataSource)
}
// File: feature-budget/src/main/java/com/openparty/feature_budget/domain/model/BudgetItem.kt
package com.openparty.app.feature_budget.domain.model

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

@Serializable
data class BudgetItem(
    @SerialName("type_of_spending") val typeOfSpending: String,
    val cost: String,
    val summary: String,
    @SerialName("subtypes_level_1") val subtypesLevel1: List<BudgetItem> = emptyList(),
    @SerialName("subtypes_level_2") val subtypesLevel2: List<BudgetItem> = emptyList()
)
// File: feature-budget/src/main/java/com/openparty/feature_budget/domain/model/BudgetResponse.kt
package com.openparty.app.feature_budget.domain.model

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

@Serializable
data class BudgetResponse(
    @SerialName("areas_of_spending") val areasOfSpending: List<BudgetItem>
)
// File: feature-budget/src/main/java/com/openparty/feature_budget/domain/repository/BudgetRepository.kt
package com.openparty.app.feature_budget.domain.repository

import com.openparty.app.feature_budget.domain.model.BudgetItem

interface BudgetRepository {
    suspend fun getBudgetData(): List<BudgetItem>
}
// File: feature-budget/src/main/java/com/openparty/feature_budget/domain/usecase/GetBudgetDataUseCase.kt
package com.openparty.app.feature_budget.domain.usecase

import com.openparty.app.feature_budget.domain.model.BudgetItem
import com.openparty.app.feature_budget.domain.repository.BudgetRepository
import javax.inject.Inject

class GetBudgetDataUseCase @Inject constructor(
    private val repository: BudgetRepository
) {
    suspend operator fun invoke(): List<BudgetItem> = repository.getBudgetData()
}
// File: feature-budget/src/main/java/com/openparty/feature_budget/presentation/components/Legend.kt
package com.openparty.app.feature_budget.presentation.components

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.background
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.openparty.app.feature_budget.domain.model.BudgetItem
import com.openparty.app.feature_budget.presentation.getColorForItem

@Composable
fun Legend(
    budgetItems: List<BudgetItem>,
    onItemClick: (BudgetItem) -> Unit
) {
    Column {
        budgetItems.forEach { item ->
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable { onItemClick(item) }
                    .padding(8.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Box(
                    modifier = Modifier
                        .size(16.dp)
                        .background(color = getColorForItem(item))
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = "${item.typeOfSpending} - ${item.cost}",
                    style = MaterialTheme.typography.bodyMedium
                )
            }
        }
    }
}
// File: feature-budget/src/main/java/com/openparty/feature_budget/presentation/BudgetContent.kt
package com.openparty.app.feature_budget.presentation

import androidx.compose.foundation.layout.Column
import androidx.compose.runtime.*
import com.openparty.app.feature_budget.domain.model.BudgetItem
import com.openparty.app.feature_budget.presentation.components.Legend

@Composable
fun BudgetContent(budgetItems: List<BudgetItem>) {
    var currentItems by remember { mutableStateOf(budgetItems) }

    Column {
        BudgetPieChart(
            budgetItems = currentItems,
            onItemClick = { selectedItem ->
                currentItems = when {
                    selectedItem.subtypesLevel1.isNotEmpty() -> selectedItem.subtypesLevel1
                    selectedItem.subtypesLevel2.isNotEmpty() -> selectedItem.subtypesLevel2
                    else -> listOf(selectedItem)
                }
            }
        )
        Legend(
            budgetItems = currentItems,
            onItemClick = { selectedItem ->
                currentItems = when {
                    selectedItem.subtypesLevel1.isNotEmpty() -> selectedItem.subtypesLevel1
                    selectedItem.subtypesLevel2.isNotEmpty() -> selectedItem.subtypesLevel2
                    else -> listOf(selectedItem)
                }
            }
        )
    }
}
// File: feature-budget/src/main/java/com/openparty/feature_budget/presentation/components/BudgetPieChart.kt
package com.openparty.app.feature_budget.presentation

import androidx.compose.foundation.layout.size
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import com.openparty.app.feature_budget.domain.model.BudgetItem
import io.github.devssrsouza.compose.charts.piechart.PieChart
import io.github.devssrsouza.compose.charts.piechart.PieChartData

@Composable
fun BudgetPieChart(
    budgetItems: List<BudgetItem>,
    onItemClick: (BudgetItem) -> Unit
) {
    val chartData = budgetItems.map {
        PieChartData.Slice(
            value = it.cost.removePrefix("£").removeSuffix(" million").toFloat(),
            color = getColorForItem(it),
            label = it.typeOfSpending
        )
    }

    PieChart(
        pieChartData = PieChartData(chartData),
        modifier = Modifier.size(200.dp),
        onSliceClicked = { index ->
            onItemClick(budgetItems[index])
        }
    )
}

fun getColorForItem(item: BudgetItem): Color {
    // Implement a method to consistently get colors for items
    // For example, map item types to specific colors
    return Color.Gray // Placeholder
}
// File: feature-budget/src/main/java/com/openparty/feature_budget/presentation/BudgetScreen.kt
package com.openparty.app.feature_budget.presentation

import androidx.compose.runtime.Composable
import androidx.hilt.navigation.compose.hiltViewModel

@Composable
fun BudgetScreen(
    viewModel: BudgetViewModel = hiltViewModel()
) {
    val budgetData = viewModel.budgetData.collectAsState().value
    BudgetContent(budgetData)
}
// File: feature-budget/src/main/java/com/openparty/feature_budget/presentation/BudgetViewModel.kt
package com.openparty.app.feature_budget.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.openparty.app.feature_budget.domain.model.BudgetItem
import com.openparty.app.feature_budget.domain.usecase.GetBudgetDataUseCase
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

@HiltViewModel
class BudgetViewModel @Inject constructor(
    private val getBudgetDataUseCase: GetBudgetDataUseCase
) : ViewModel() {

    private val _budgetData = MutableStateFlow<List<BudgetItem>>(emptyList())
    val budgetData: StateFlow<List<BudgetItem>> = _budgetData

    init {
        viewModelScope.launch {
            _budgetData.value = getBudgetDataUseCase()
        }
    }
}
// File: app/src/main/java/com/openparty/app/navigation/AppNavHost.kt
package com.openparty.app.navigation

import androidx.compose.runtime.Composable
import androidx.navigation.NavHostController
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import com.openparty.app.feature_budget.presentation.BudgetScreen
import com.openparty.feature_proposals.presentation.ProposalsScreen
import com.openparty.feature_newsfeed.presentation.NewsfeedScreen

@Composable
fun AppNavHost(navController: NavHostController) {
    NavHost(navController, startDestination = Screen.Budget.route) {
        composable(Screen.Budget.route) {
            BudgetScreen()
        }
        composable(Screen.Proposals.route) {
            ProposalsScreen()
        }
        composable(Screen.Newsfeed.route) {
            NewsfeedScreen()
        }
    }
}
// File: app/src/main/java/com/openparty/app/ui/components/BottomNavBar.kt
package com.openparty.app.navigation

import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Article
import androidx.compose.material.icons.filled.Lightbulb
import androidx.compose.material.icons.filled.PieChart
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.navigation.compose.currentBackStackEntryAsState
import androidx.navigation.NavHostController

@Composable
fun BottomNavBar(navController: NavHostController) {
    val items = listOf(
        Screen.Budget,
        Screen.Proposals,
        Screen.Newsfeed
    )
    NavigationBar {
        val currentRoute = navController.currentBackStackEntryAsState().value?.destination?.route
        items.forEach { screen ->
            val icon: ImageVector = when (screen) {
                is Screen.Budget -> Icons.Default.PieChart
                is Screen.Proposals -> Icons.Default.Lightbulb
                is Screen.Newsfeed -> Icons.Default.Article
            }
            NavigationBarItem(
                icon = { Icon(imageVector = icon, contentDescription = screen.route) },
                label = { Text(screen.route.capitalize()) },
                selected = currentRoute == screen.route,
                onClick = {
                    navController.navigate(screen.route) {
                        popUpTo(navController.graph.startDestinationId) { saveState = true }
                        launchSingleTop = true
                        restoreState = true
                    }
                }
            )
        }
    }
}
// File: navigation/src/main/java/com/openparty/navigation/Screen.kt
package com.openparty.app.navigation

sealed class Screen(val route: String) {
    object Budget : Screen("budget")
    object Proposals : Screen("proposals")
    object Newsfeed : Screen("newsfeed")
}
// File: app/src/main/java/com/openparty/app/MainActivity.kt
package com.openparty.app

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Scaffold
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.navigation.compose.rememberNavController
import com.openparty.app.navigation.AppNavHost
import com.openparty.app.navigation.BottomNavBar
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            OpenPartyApp()
        }
    }
}

@Composable
fun OpenPartyApp() {
    val navController = rememberNavController()
    Scaffold(
        bottomBar = { BottomNavBar(navController) }
    ) { paddingValues ->
        Box(modifier = Modifier.padding(paddingValues)) {
            AppNavHost(navController)
        }
    }
}
// File: app/src/main/java/com/openparty/app/MyApplication.kt
package com.openparty.app

import android.app.Application
import dagger.hilt.android.HiltAndroidApp

@HiltAndroidApp
class MyApplication : Application()
