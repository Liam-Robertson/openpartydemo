com.openparty.app
├── core
├── di
│   └── BudgetModule.kt
├── feature_budget
│   ├── data
│   │   ├── datasource
│   │   │   └── BudgetDataSource.kt
│   │   └── repository
│   │       └── BudgetRepositoryImpl.kt
│   ├── domain
│   │   ├── model
│   │   │   ├── BudgetItem.kt
│   │   │   └── BudgetResponse.kt
│   │   ├── repository
│   │   │   └── BudgetRepository.kt
│   │   └── usecase
│   │       └── GetBudgetDataUseCase.kt
│   └── presentation
│       ├── components
│       │   ├── BudgetPieChart.kt
│       │   └── Legend.kt
│       ├── BudgetContent.kt
│       ├── BudgetScreen.kt
│       └── BudgetViewModel.kt
├── feature_proposals
│   └── presentation
│       └── ProposalsScreen.kt
├── feature_newsfeed
│   └── presentation
│       └── NewsfeedScreen.kt
│── navigation
│   ├── AppNavHost.kt
│   ├── BottomNavBar.kt
│   └── Screen.kt
│── ui.theme
│   ├── Color.kt
│   ├── Theme.kt
│   └── Type.kt
├── MainActivity.kt
└── MyApplication.kt

---------------------------------

Budget Screen:
- The aim of the budget screen is to represent the amount of spending in each area of government in pie chart form
- It gets information about government spending from a database, calculates the percentage spending in each area, then displays that information to the user in a pie chart
- The budget screen has three parts:
    - A title saying "Budget"
    - A pie chart. This has a legend showing what each section corresponds to
    - A footer:
        - The footer is used for navigation
        - It is made up of three sections - a budget section, a newsfeed section and a proposals section
        - Each section is represented by an icon
        - When the user clicks on a section, it navigates to that page
        - When the app is first opens, it defaults navigation to the budget section
        - When the budget screen is open, the budget section is highlighted. When the minutes screen is open, the minutes section is highlighted

When the user enters the budget screen this happens:
- The data about the financial report is fetched
    - The data about the financial report will be stored in a separate file
    - Right now this is just a version 1 of an app, so the data will be hardcoded
    - The data will be hardcoded for each section
    - The data will be in this format:
{
  "areas_of_spending": [
    {
      "type_of_spending": "Education Services",
      "cost": "£220.806 million",
      "summary": "This category encompasses all spending related to educational services provided by the council, including staffing costs for teachers and support staff, educational materials, school maintenance, and administrative support.",
      "subtypes_level_1": [
        {
          "type_of_spending": "Schools and Education Support",
          "cost": "£220.806 million",
          "summary": "This subtype includes costs for teaching staff salaries, educational materials, school facility maintenance, special education needs, and administrative support services.",
          "subtypes_level_2": [
            {
              "type_of_spending": "Early Learning and Childcare",
              "cost": "£17.850 million",
              "summary": "Provision of early childhood education and childcare services for children under the age of five."
            },
.....

    - i.e. the data will be in json format with the area of spending, the cost the summary and then the same again for all the subtypes of spending
    - When the user enters the screen, the data will be fetched from the json file which is com.openparty.app.notes.descriptionsV1.financeDataV1.json
    - This data will then be used to populate the pie chart
    - The pie chart will initially just be populated using the highest level of data i.e. type of spending, not type of spending level 1 or level 2
    - There will be a legend at the bottom of the screen which shows each area of spending, it's cost and it's colour on the pie chart
    - If the user clicks on a section in the legend, the app shows a new pie chart which gives a more detailed breakdown of that type of spending
    - For example, the initial pie chart might show up with Education Services, Social Care Services, Housing services
    - Each of these would be represented in the pie chart as a different colour, and each would take up a piece of the pie chart proportional to the level of spending on them
        - e.g. if Education was 37% of spending it would take up 37% of the pie chart
    - At the bottom of the screen is a legend showing Education Services, Social Care Services, Housing services - along with the colour and cost associated with each
    - If the user then clicked on Social Care Services in the legend, a new pie chart would appear which has all the subtypes of Social Care Services spending
        - i.e."Adult and Elderly Services (IJB)", "Children's Services (Non-IJB)"
    - The new pie chart would have each sub type of spending
    - The new legend would have the sub type of spending, the colour on the pie chart, the cost
    - If the user clicks on a subtype of spending in the legend, then a new pie chart would appear for sub type level 2
    - The new pie chart and legend would have the type of spending, cost and colour for spending sub type 2 in the json file

Navigation:
- The navigation needs to be able to handle navigating between the budget section, newsfeed section and proposals section
- This app is going to get a lot more complex so the navigation functionality needs to be able to handle that
- The navigation should probably have it's own feature

---------------------------------

// File: feature-budget/src/main/java/com/openparty/feature_budget/di/BudgetModule.kt
package com.openparty.app.di

import com.openparty.app.feature_budget.data.datasource.BudgetDataSource
import com.openparty.app.feature_budget.data.repository.BudgetRepositoryImpl
import com.openparty.app.feature_budget.domain.repository.BudgetRepository
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object BudgetModule {

    @Provides
    @Singleton
    fun provideBudgetRepository(
        dataSource: BudgetDataSource
    ): BudgetRepository = BudgetRepositoryImpl(dataSource)
}
// File: feature-budget/src/main/java/com/openparty/feature_budget/data/datasource/BudgetDataSource.kt
package com.openparty.app.feature_budget.data.datasource

import android.content.Context
import com.openparty.app.feature_budget.domain.model.BudgetItem
import com.openparty.app.feature_budget.domain.model.BudgetResponse
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.json.Json

class BudgetDataSource @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val jsonFormat = Json { ignoreUnknownKeys = true }

    suspend fun fetchBudgetData(): List<BudgetItem> {
        val jsonString = withContext(Dispatchers.IO) {
            context.assets.open("financeDataV1.json").bufferedReader().use { it.readText() }
        }
        val response = jsonFormat.decodeFromString<BudgetResponse>(jsonString)
        return response.areasOfSpending
    }
}
// File: feature-budget/src/main/java/com/openparty/feature_budget/data/repository/BudgetRepositoryImpl.kt
package com.openparty.app.feature_budget.data.repository

import com.openparty.app.feature_budget.data.datasource.BudgetDataSource
import com.openparty.app.feature_budget.domain.model.BudgetItem
import com.openparty.app.feature_budget.domain.repository.BudgetRepository
import javax.inject.Inject

class BudgetRepositoryImpl @Inject constructor(
    private val dataSource: BudgetDataSource
) : BudgetRepository {
    override suspend fun getBudgetData(): List<BudgetItem> {
        return dataSource.fetchBudgetData()
    }
}
// File: feature-budget/src/main/java/com/openparty/feature_budget/domain/model/BudgetItem.kt
package com.openparty.app.feature_budget.domain.model

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

@Serializable
data class BudgetItem(
    @SerialName("type_of_spending") val typeOfSpending: String,
    val cost: String,
    val summary: String,
    @SerialName("subtypes_level_1") val subtypesLevel1: List<BudgetItem> = emptyList(),
    @SerialName("subtypes_level_2") val subtypesLevel2: List<BudgetItem> = emptyList()
)
// File: feature-budget/src/main/java/com/openparty/feature_budget/domain/model/BudgetResponse.kt
package com.openparty.app.feature_budget.domain.model

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

@Serializable
data class BudgetResponse(
    @SerialName("areas_of_spending") val areasOfSpending: List<BudgetItem>
)
// File: feature-budget/src/main/java/com/openparty/feature_budget/domain/repository/BudgetRepository.kt
package com.openparty.app.feature_budget.domain.repository

import com.openparty.app.feature_budget.domain.model.BudgetItem

interface BudgetRepository {
    suspend fun getBudgetData(): List<BudgetItem>
}
// File: feature-budget/src/main/java/com/openparty/feature_budget/domain/usecase/GetBudgetDataUseCase.kt
package com.openparty.app.feature_budget.domain.usecase

import com.openparty.app.feature_budget.domain.model.BudgetItem
import com.openparty.app.feature_budget.domain.repository.BudgetRepository
import javax.inject.Inject

class GetBudgetDataUseCase @Inject constructor(
    private val repository: BudgetRepository
) {
    suspend operator fun invoke(): List<BudgetItem> = repository.getBudgetData()
}
// File: feature-budget/src/main/java/com/openparty/feature_budget/presentation/components/Legend.kt
package com.openparty.app.feature_budget.presentation.components

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.background
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.openparty.app.feature_budget.domain.model.BudgetItem
import com.openparty.app.feature_budget.presentation.getColorForItem

@Composable
fun Legend(
    budgetItems: List<BudgetItem>,
    onItemClick: (BudgetItem) -> Unit
) {
    Column {
        budgetItems.forEach { item ->
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable { onItemClick(item) }
                    .padding(8.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Box(
                    modifier = Modifier
                        .size(16.dp)
                        .background(color = getColorForItem(item))
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = "${item.typeOfSpending} - ${item.cost}",
                    style = MaterialTheme.typography.bodyMedium
                )
            }
        }
    }
}
package com.openparty.app.feature_budget.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.openparty.app.feature_budget.domain.model.BudgetItem
import com.openparty.app.feature_budget.presentation.components.BudgetPieChart
import com.openparty.app.feature_budget.presentation.components.Legend

@Composable
fun BudgetContent(budgetItems: List<BudgetItem>) {
    var currentItems by remember { mutableStateOf(budgetItems) }

    Column(
        modifier = Modifier.fillMaxSize().padding(16.dp)
    ) {
        Text(
            text = "West Lothian Budget",
            style = MaterialTheme.typography.headlineSmall,
            modifier = Modifier.align(Alignment.Start)
        )

        Spacer(modifier = Modifier.height(32.dp))

        Box(
            modifier = Modifier.fillMaxWidth(),
            contentAlignment = Alignment.Center
        ) {
            BudgetPieChart(
                budgetItems = currentItems,
                onItemClick = { selectedItem ->
                    currentItems = when {
                        selectedItem.subtypesLevel1.isNotEmpty() -> selectedItem.subtypesLevel1
                        selectedItem.subtypesLevel2.isNotEmpty() -> selectedItem.subtypesLevel2
                        else -> listOf(selectedItem)
                    }
                }
            )
        }

        Spacer(modifier = Modifier.height(32.dp))

        Legend(
            budgetItems = currentItems,
            onItemClick = { selectedItem ->
                currentItems = when {
                    selectedItem.subtypesLevel1.isNotEmpty() -> selectedItem.subtypesLevel1
                    selectedItem.subtypesLevel2.isNotEmpty() -> selectedItem.subtypesLevel2
                    else -> listOf(selectedItem)
                }
            }
        )
    }
}
// File: feature_budget/src/main/java/com/openparty/feature_budget/presentation/components/BudgetPieChart.kt
package com.openparty.app.feature_budget.presentation.components

import androidx.compose.foundation.layout.size
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.unit.dp
import me.bytebeats.views.charts.pie.PieChart
import me.bytebeats.views.charts.pie.PieChartData
import me.bytebeats.views.charts.pie.render.SimpleSliceDrawer
import com.openparty.app.feature_budget.domain.model.BudgetItem
import com.openparty.app.feature_budget.presentation.getColorForItem

@Composable
fun BudgetPieChart(
    budgetItems: List<BudgetItem>,
    onItemClick: (BudgetItem) -> Unit
) {
    val pieSlices = budgetItems.mapNotNull { item ->
        val parsedValue = item.cost
            .replace("£", "")
            .replace(",", "")
            .replace(" million", "")
            .trim()
            .toFloatOrNull() ?: return@mapNotNull null

        PieChartData.Slice(
            value = parsedValue,
            color = getColorForItem(item)
        )
    }

    PieChart(
        pieChartData = PieChartData(pieSlices),
        modifier = Modifier.size(200.dp),
        sliceDrawer = SimpleSliceDrawer(sliceThickness = 50f)
    )
}
// File: feature-budget/src/main/java/com/openparty/feature_budget/presentation/BudgetScreen.kt
package com.openparty.app.feature_budget.presentation

import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.hilt.navigation.compose.hiltViewModel

@Composable
fun BudgetScreen(
    viewModel: BudgetViewModel = hiltViewModel()
) {
    val budgetData = viewModel.budgetData.collectAsState().value
    BudgetContent(budgetData)
}
// File: feature-budget/src/main/java/com/openparty/feature_budget/presentation/BudgetViewModel.kt
package com.openparty.app.feature_budget.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.openparty.app.feature_budget.domain.model.BudgetItem
import com.openparty.app.feature_budget.domain.usecase.GetBudgetDataUseCase
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class BudgetViewModel @Inject constructor(
    private val getBudgetDataUseCase: GetBudgetDataUseCase
) : ViewModel() {

    private val _budgetData = MutableStateFlow<List<BudgetItem>>(emptyList())
    val budgetData: StateFlow<List<BudgetItem>> = _budgetData.asStateFlow()

    init {
        viewModelScope.launch {
            val data = getBudgetDataUseCase()
            _budgetData.value = data
        }
    }
}
// File: feature_budget/src/main/java/com/openparty/feature_budget/presentation/getColorForItem.kt
package com.openparty.app.feature_budget.presentation

import androidx.compose.ui.graphics.Color
import com.openparty.app.feature_budget.domain.model.BudgetItem

fun getColorForItem(item: BudgetItem): Color {
    return when (item.typeOfSpending) {
        "Housing Services" -> Color(0xFF42A5F5) // Blue
        "Transportation Services" -> Color(0xFFFFA726) // Orange
        "Education Services" -> Color(0xFF66BB6A) // Green
        "Social Care Services" -> Color(0xFFAB47BC) // Purple
        "Healthcare Services" -> Color(0xFFEF5350) // Red
        else -> Color(0xFF9E9E9E) // Default Grey
    }
}
// File: app/src/main/java/com/openparty/app/navigation/AppNavHost.kt
package com.openparty.app.navigation

import androidx.compose.runtime.Composable
import androidx.navigation.NavHostController
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import com.openparty.app.feature_budget.presentation.BudgetScreen
import com.openparty.feature_proposals.presentation.ProposalsScreen
import com.openparty.feature_newsfeed.presentation.NewsfeedScreen

@Composable
fun AppNavHost(navController: NavHostController) {
    NavHost(navController, startDestination = Screen.Budget.route) {
        composable(Screen.Budget.route) {
            BudgetScreen()
        }
        composable(Screen.Proposals.route) {
            ProposalsScreen()
        }
        composable(Screen.Newsfeed.route) {
            NewsfeedScreen()
        }
    }
}
// File: app/src/main/java/com/openparty/app/ui/components/BottomNavBar.kt
package com.openparty.app.navigation

import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Article
import androidx.compose.material.icons.filled.Lightbulb
import androidx.compose.material.icons.filled.PieChart
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.navigation.compose.currentBackStackEntryAsState
import androidx.navigation.NavHostController

@Composable
fun BottomNavBar(navController: NavHostController) {
    val items = listOf(
        Screen.Budget,
        Screen.Proposals,
        Screen.Newsfeed
    )
    NavigationBar {
        val currentRoute = navController.currentBackStackEntryAsState().value?.destination?.route
        items.forEach { screen ->
            val icon: ImageVector = when (screen) {
                is Screen.Budget -> Icons.Default.PieChart
                is Screen.Proposals -> Icons.Default.Lightbulb
                is Screen.Newsfeed -> Icons.Default.Article
            }
            NavigationBarItem(
                icon = { Icon(imageVector = icon, contentDescription = screen.route) },
                label = { Text(screen.route.capitalize()) },
                selected = currentRoute == screen.route,
                onClick = {
                    navController.navigate(screen.route) {
                        popUpTo(navController.graph.startDestinationId) { saveState = true }
                        launchSingleTop = true
                        restoreState = true
                    }
                }
            )
        }
    }
}
// File: navigation/src/main/java/com/openparty/navigation/Screen.kt
package com.openparty.app.navigation

sealed class Screen(val route: String) {
    object Budget : Screen("budget")
    object Proposals : Screen("proposals")
    object Newsfeed : Screen("newsfeed")
}
// File: app/src/main/java/com/openparty/app/MainActivity.kt
package com.openparty.app

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Scaffold
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.navigation.compose.rememberNavController
import com.openparty.app.navigation.AppNavHost
import com.openparty.app.navigation.BottomNavBar
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            OpenPartyApp()
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun OpenPartyApp() {
    val navController = rememberNavController()
    Scaffold(
        bottomBar = { BottomNavBar(navController) }
    ) { paddingValues ->
        Box(modifier = Modifier.padding(paddingValues)) {
            AppNavHost(navController)
        }
    }
}
// File: app/src/main/java/com/openparty/app/MyApplication.kt
package com.openparty.app

import android.app.Application
import dagger.hilt.android.HiltAndroidApp

@HiltAndroidApp
class MyApplication : Application()

-------------------

This code mostly works but it has some issues

When the user opens the app I want this to happen: 
- The user opens the app
- The app defaults to the budget screen
- The budget screen shows the title, the pie chart and the legend 

When the user opens the app I want this to happen: 
- The user opens the app
- The app defaults to the budget screen
- The budget screen shows the title and nothing else

Problem:
- The budget screen, when opened, shows the title but doesn't show the pie chart 
- If I swipe to the proposals screen then back to the budget screen, the pie chart then shows up 
- This suggests the problem is likely a loading error i.e. the screen renders before the pie chart has loaded 
- Fix this
- If it's a loading error, it's probably best to show a loading screen while the app is loading 
- If you use a loading screen, have the loading screen just show the material compost icon 
  - Give the compost icon a pulsing animation 
  - Make sure that, if the loading screen is shown, it appears for at least 1 second
  - I don't want the loading screen to be shown for 0.1 seconds because that's disorienting to the user 
  - Instead, I want the minimum loading screen time to be 1 second 
  - For example, if it takes 0.05 seconds for the data to load, the loading screen should be shown for 1 second
  - If the data takes 2 seconds to load, the loading screen should be shown for 2 seconds 

-----

Thank you, that works. 

I also want to add this functionality: 

What happens right now, when the user clicks a category in the legend on the budget screen: 
- The user opens the budget screen, it shows the title, pie chart and legend
- The user clicks a category on the budget screen like Social Care Services
- The user is shown a new screen which has a title, pie chart and legend, but now it's showing the pie chart data for social care services subtype level 1 data 

What I want to happen, when the user clicks a category in the legend on the budget screen: 
- The user opens the budget screen, it shows the title, pie chart and legend
- The user clicks a category on the budget screen like Social Care Services
- The user is shown a new screen which has a back button at the top, title, pie chart and legend, but now it's showing the pie chart data for social care services subtype level 1 data 

Problem: 
- When the user clicks on a category of spending it shows them the screen for the sub level of spending (as it should) but it doesn't give them a way to get back to the previous level of spending 
- For example, Let's call "Housing Services" level 1 spending, "Housing Revenue Account" level 2 spending, "Repairs and Maintenance" level 3 spending 
  - I want the user to be able to navigate between level 1, 2 and 3 spending easily 
  - Right now they can navigate from level 1 to level 2 spending by clicking on the spending category in the legend, however they cannot navigate  from level 2 back to level 1 
  - I want to add a back button on sub types of spending which take you back to the previous level of spending 
  - If you click on the back button when you are on level 2 spending, it takes you back to level 1 spending 
  - If you click on the back button when you are on level 3 spending, it takes you back to level 2 spending 

----

I also want to add another change: 
- Right now, the pie chart will show the user all types of spending in the budget screen, even if they are extremely small types of spending 
  - For example, if their was 0.005% of spending on "Gaelic Lessons" then the budget screen would show that in the pie chart 
- I don't want that. On the initial screen of the budget screen (which represents level 1 spending), any types of spending that represent 5% of the overall total should be grouped together in a category called "Miscellaneous" 
- If the user clicks on the Miscellaneous section of the legend, it will show the user a level 2 spending screen, but this time, the level 2 spending will be all of the spending will be all of the spending types that are grouped under miscelleous 

I'll give you an example to make this more clear: 
- The user clicks on the budget screen 
- The hardcoded data has this in it: 
